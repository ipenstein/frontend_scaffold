/*
# base/_toolbelt.scss

A collection of helper mixins, placeholders and classes.
*/

/*
# .clearfix helper class

Don't use clearfix-mixin from compass as it isn't considered a best practice.
Use HTML5-Boilerplate's @mixin micro-clearfix instead.
*/
.clearfix {
    @include micro-clearfix;
}

/*
# box-sizing mixin with prefixes
*/
@mixin box-sizing($value) {
    -moz-box-sizing: $value;
         box-sizing: $value;
}

/*
# @mixin bp

Mixin to manage responsive breakpoints.
Feel free to add more breakpoints in "base/_vars.scss".

@author Hugo Giraudel
@param {String} $breakpoint - Breakpoint name
@require $breakpoints

    $breakpoints: small 500px, medium 700px, big 900px;
    .wrapper {
        width: 220px;
        @include bp(small) {
            width: 460px;
        }
    }

*/

// Min-width breakpoints
@mixin bp($breakpoint) {
    @if map-has-key($breakpoints, $breakpoint) {
        @media (min-width: map-get($breakpoints, $breakpoint)) {
            @content;
        }
    }
    @else {
        @warn "Unfortunately, no value could be retrieved from `#{$breakpoint}`. "
            + "Available breakpoints are: #{map-keys($breakpoints)}.";
    }
}

// Max-width breakpoints
@mixin bp-max($breakpoint) {
    @if map-has-key($breakpoints, $breakpoint) {
        @media (max-width: map-get($breakpoints, $breakpoint)) {
            @content;
        }
    }
    @else {
        @warn "Unfortunately, no value could be retrieved from `#{$breakpoint}`. "
            + "Available breakpoints are: #{map-keys($breakpoints)}.";
    }
}

/*
# @mixin hd

Retina breakpoint.
*/
@mixin hd($ratio: 2, $resolution: 192dpi) {
    @media (-min-device-pixel-ratio: $ratio), (min-resolution: $resolution) {
        @content;
    }
}

/*
# Dynamic classes based on $breakpoints.

Dont't show an element until or hide it starting at a specific breakpoint.

$breakpoints: small 500px, medium 700px, big 900px;
.reveal-small {}
.reveal-medium {}
.reveal-big {}
.hide-small {}
.hide-medium {}
.hide-big {}
*/
@each $breakpoint in $breakpoints {
    $name: nth($breakpoint, 1);
    $width: nth($breakpoint, 2);
    .hide-#{$name} {
        @media (min-width: $width) {
            display: none !important;
        }
    }
    .reveal-#{$name} {
        display: none !important;
        @media (min-width: $width) {
            display: block !important;
        }
    }
}

/*
# @function z

Gather all z-indexes into a single map, and stick to them. Then you know how
many layers the application uses, making it easy to understand what’s going on
(and, sooner or later, to debug).

@param {String} $z - layer name
@require $z-layers
*/
@function z($key) {
    @if map-has-key($z-layers, $key) {
        @return map-get($z-layers, $key);
    }

    @warn "Unknown `#{$key}` in $z-layers.";
    @return null;
}

/*
# REM font-size and line-height with px-fallback

http://css-tricks.com/snippets/css/less-mixin-for-rem-font-sizing/
*/
@mixin font-size($sizeValue: 16, $line: $sizeValue * 1.5) {
    font-size: ($sizeValue) + px;
    line-height: ($line) + px;
    font-size: ($sizeValue / 10) + rem;
    line-height: ($line / 10) + rem;
}

/*
# @mixin word-wrap
*/
@mixin word-wrap {
    word-break: break-word;
    -webkit-hyphens: auto;
       -moz-hyphens: auto;
            hyphens: auto;
}

/*
# @mixin truncate-text

Ensuring that your text element doesn’t overflow its container and breaks
nicely. It takes one parameter, which is any of the valid text-overflow values.

http://hackingui.com/front-end/10-best-scss-utilities/
*/
@mixin truncate-text( $overflow: ellipsis ) {
    overflow: hidden;
    white-space: nowrap;
    text-overflow: $overflow; // values are: clip, ellipsis, or a string
}

/*
# @mixin cover everything
*/
@mixin cover {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

/*
# @mixin center-vertical

For vertically centering elements with a dynamic size. Works beautifully and
doesn’t require an extra, non-semantic HTML element.

http://hackingui.com/front-end/10-best-scss-utilities/
*/
@mixin center-vertical {
    &:before {
        content: '';
        @include inline-block;
        height: 100%; width: .1px;
    }
}

/*
# @mixin center-both

Horizontally and vertically center elements with a dynamic size. Works only
in modern Browsers.
*/
@mixin center-both {
    position: absolute;
    top: 50%;
    left: 50%;
    @include translate(-50%, -50%);
}

/*
# @mixin no-list

Reset list styles (list-style-type, margin, padding)
*/
@mixin no-list {
    &,
    & li {
        list-style: none;
        background-image: none;
        padding: 0;
    }
}

/*
# %currency

Display a currency symbol on any type of text element.

    .price {
        @extend %currency;
    }

    <body class="EUR">
        <span class="price">45</span>
    </body>

http://hackingui.com/front-end/10-best-scss-utilities/
*/
%currency {
    position: relative;
    &:before {
        content: '\20AC';
        position: relative;
        left: 0;
    }
}
.USD %currency:before { content: '$'; }
.EUR %currency:before { content: '\20AC'; }
.ILS %currency:before { content: '\20AA'; }
.GBP %currency:before { content: '\00A3'; }

/*
# @mixin caret

Creates a right angled triangle pointing to a direction specified by $direction.

$direction: top, right, bottom or left
$size: px-value
$color: color-value
*/
@mixin caret($direction: top, $size: 10px, $color: #333) {
    $opposite: opposite-position($direction);
    border: $size solid transparent;
    border-#{$opposite}: $size solid $color;
    border-#{$direction}: 0;
    height: 0;
    width: 0;
}

/*
# @mixin gradient-transition

Creates a :hover-transition-effect with a gradient.

$start: color-value
$end: color-value
$time: transition duration

*/
@mixin gradient-transition( $start, $end, $duration ){
    background-size: 100%;
    background-image: linear-gradient($start, $end);
    position: relative;
    z-index: 100;
    &:before {
        background-image: linear-gradient($end, $start);
        content: '';
        display: block;
        height: 100%;
        position: absolute;
        top: 0; left: 0;
        opacity: 0;
        width: 100%;
        z-index: -100;
        transition: opacity $duration;
    }
    &:hover {
        &:before {
            opacity: 1;
        }
    }
}

/*
# Webkit Scrollbar Styling

http://codepen.io/HugoGiraudel/details/KFDuB
*/
@mixin scrollbar($size, $primary, $secondary: lighten($primary, 25%)) {
    ::-webkit-scrollbar {
        width:  $size;
        height: $size;
    }

    ::-webkit-scrollbar-thumb {
        background: $primary;
    }

    ::-webkit-scrollbar-track {
        background: $secondary;
    }

    // For Internet Explorer
    body {
        scrollbar-face-color: $primary;
        scrollbar-track-color: $secondary;
    }
}

@mixin visually-hidden() {
    position: absolute;
    z-index: -1;
    opacity: 0;
    width: 1px;
    height: 1px;
    margin: -1px;
    padding: 0;
    border: 0;
    clip: rect(0 0 0 0);
    overflow: hidden;
}

#responsive-status {
    display: none;
    font-family: "mobile";
}
@each $breakpoint in $breakpoints {
    $name: nth($breakpoint, 1);
    $width: nth($breakpoint, 2);
    @media (min-width: $width) {
        #responsive-status {
            font-family: "#{$name}";
        }
    }
}